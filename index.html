<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>> lightmagnets $</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <!-- <link rel="stylesheet" type="text/css" media="screen" href="main.css" /> -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/two.js/0.6.0/two.js"></script>
    <style>
      #stage {
        margin: 0 auto;
        width: 500px;
      }
    </style>
  </head>

  <body>
    <div id="stage"></div>
    <script>
      const elem = document.getElementById('stage');

      // width and height of each grid box
      const gridSize = 16;

      // number of points
      const stageWidth = 32 * gridSize; // x limit
      const stageHeight = 32 * gridSize; // y limit

      const two = new Two({
        width: stageWidth,
        height: stageHeight
      }).appendTo(elem);

      const stage = two.makeRectangle(
        stageWidth / 2,
        stageHeight / 2,
        stageWidth,
        stageHeight
      );
      stage.fill;
      stage.stroke = '#000';
      stage.linewidth = 1;

      // create grid
      for (let x = 0; x <= stageWidth; x += gridSize) {
        two.makeLine(x, 0, x, stageHeight);
      }
      for (let y = 0; y <= stageHeight; y += gridSize) {
        two.makeLine(0, y, stageWidth, y);
      }

      // create players
      const playerSize = 6;
      function createPlayerCircle(x, y, color) {
        const circle = two.makeCircle(x, y, playerSize);
        circle.stroke = color;
        circle.fill = '#fff';
        circle.linewidth = 2;
        return circle;
      }

      const user = {
        name: 'user',
        prevDirection: 'down',
        direction: 'down',
        speed: 1,
        alive: true,
        group: createPlayerCircle(gridSize, gridSize, '#3498db'),
        color: '#3498db',
        currentOrigin: new Two.Vector(gridSize, gridSize),
        lightTrails: []
      };

      const enemy = {
        name: 'enemy',
        alive: true,
        group: createPlayerCircle(
          stageWidth - gridSize,
          stageHeight - gridSize,
          '#e67e22'
        ),
        color: '#e67e22',
        // TODO: Change me
        currentOrigin: new Two.Vector(stageWidth - gridSize, 0),
        lightTrails: []
      };

      const players = [user, enemy];

      two.update();

      function checkCollision(player) {
        const trn = player.group.translation;
        if (
          trn.x >= stageWidth - playerSize || // right limit
          trn.x <= 0 + playerSize || // left limit
          trn.y >= stageHeight - playerSize || // down limit
          trn.y <= 0 + playerSize // up limit
        ) {
          console.log('Hit the arena');
          return true;
        }

        const pr = player.group.getBoundingClientRect();

        let collidedWithTrail = players.some(_player => {
          return _player.lightTrails.some(trail => {
            const tr = trail.getBoundingClientRect();
            if (
              !(
                pr.right < tr.left ||
                pr.left > tr.right ||
                pr.bottom < tr.top ||
                pr.top > tr.bottom
              )
            ) {
              // should be immune to your last created trail
              const lt = player.lightTrails;
              if (lt.length > 0 && lt[lt.length - 1].id === trail.id) {
                // skip
              } else {
                console.log(
                  player.name,
                  'collided with',
                  _player.name,
                  'lighttrail'
                );
                return true;
              }
            }
          });
        });
        return collidedWithTrail;
      }

      function createLightTrail(player) {
        // deferred creation of lighttrails
        const lightTrail = two.makeLine(
          player.currentOrigin.x,
          player.currentOrigin.y,
          player.group.translation.x,
          player.group.translation.y
        );
        lightTrail.stroke = player.color;
        lightTrail.linewidth = playerSize;
        lightTrail.opacity = 0.9;
        lightTrail.origin = player.currentOrigin;

        // If lines have same origin, remove them from the list
        if (player.lightTrails.length > 0) {
          const lastTrail = player.lightTrails[player.lightTrails.length - 1];
          if (lastTrail.origin.equals(lightTrail.origin)) {
            two.remove(player.lightTrails.pop());
          }
        }
        player.lightTrails.push(lightTrail);
      }

      createLightTrail(enemy);
      const speedPerTick = 1; //playerSize;
      const leftVec = new Two.Vector(-speedPerTick, 0);
      const rightVec = new Two.Vector(speedPerTick, 0);
      const upVec = new Two.Vector(0, -speedPerTick);
      const downVec = new Two.Vector(0, speedPerTick);

      function generateMove(player) {
        const trn = player.group.translation;
        if (player.direction !== player.prevDirection) {
          player.currentOrigin = player.group.translation.clone();
        }
        for (let i = 0; i < player.speed; i++) {
          switch (player.direction) {
            case 'left':
              trn.addSelf(leftVec);
              break;
            case 'right':
              trn.addSelf(rightVec);
              break;
            case 'up':
              trn.addSelf(upVec);
              break;
            case 'down':
              trn.addSelf(downVec);
              break;
          }
          if (checkCollision(player)) {
            console.log(player.name, 'died.');
            player.alive = false;
            return;
          }
          createLightTrail(player);
          // Make circle on top of trail
          two.remove(player.group);
          player.group = createPlayerCircle(trn.x, trn.y, user.color);
        }
        player.prevDirection = player.direction;
      }

      function runTimes(n) {
        for (let i = 0; i < n; i++) {
          generateMove(user);
          two.update();
        }
      }

      const lightTrails = [];

      // user controls
      document.body.onkeydown = k => {
        switch (k.code) {
          case 'KeyS':
            if (user.prevDirection !== 'up') {
              user.direction = 'down';
            }
            break;
          case 'KeyW':
            if (user.prevDirection !== 'down') {
              user.direction = 'up';
            }
            break;
          case 'KeyA':
            if (user.prevDirection !== 'right') {
              user.direction = 'left';
            }
            break;
          case 'KeyD':
            if (user.prevDirection !== 'left') {
              user.direction = 'right';
            }
            break;
          case 'KeyT':
            if (user.speed < 3) {
              user.speed += 1;
            }
            break;
          case 'KeyG':
            if (user.speed > 1) {
              user.speed -= 1;
            }
            break;
        }
      };
      two
        .bind('update', frameCount => {
          if (players.every(p => p.alive)) {
            generateMove(user);
          }
        })
        .play();
    </script>
  </body>
</html>
